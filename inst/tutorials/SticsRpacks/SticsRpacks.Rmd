---
title: "Tutorial for SticsRPacks"
output: 
  learnr::tutorial:
    theme: cerulean
    ace_theme: pastel_on_dark
    anchor_sections: FALSE
    progressive: FALSE
    df_print: "paged"
description: "A tutorial to learn SticsRPacks"
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
library(SticsRPacks)
library(dplyr)
library(tidyr)
library(ggplot2)
options(stringsAsFactors = FALSE) 

# library(gradethis)
knitr::opts_chunk$set(echo = FALSE)
tutorial_options(exercise.lines = 5, exercise.timelimit = 60)
# gradethis::gradethis_setup()

# Add checking JavaStics path

parameters = list(
  gen_help = TRUE,
  javastics = "JavaSTICS-1.41-stics-9.2",
  workspace_xml = "JavaSTICS-1.41-stics-9.2/example",
  workspace_PW1 = "tutorials/SticsRpacks/PW1",
  workspace_txt = "example",
  use_default = TRUE,
  work_dir = file.path(normalizePath(dirname(tempdir()), winslash = "/"), "SticsRPacks")
)

work_dir <- parameters$work_dir

# For avoiding problems under windows
# with spaces in user dir path
if (.Platform$OS.type == "windows") {
  work_dir <- shortPathName(work_dir)
}

work_dir <- gsub(pattern = "\\\\", replacement="/", x=work_dir)

# Creating work_dir if needed
if (!dir.exists(work_dir)) dir.create(work_dir)

javastics <- file.path(work_dir, parameters$javastics, fsep ="/")

if (!dir.exists(javastics)) dir.create(javastics)

if(!any(grepl("JavaStics.exe",list.files(javastics)))) {
  zip_path <- file.path(work_dir,paste0(parameters$javastics,".zip"))
  system(paste0("curl -u stics_user:w10lptr6405 https://w3.avignon.inra.fr/forge/attachments/download/2482/",parameters$javastics,".zip --output ", zip_path))
  unzip(zip_path, exdir = javastics)
}

workspace_xml <- file.path(work_dir, parameters$workspace_xml, fsep ="/")
workspace_txt <- file.path(work_dir, parameters$workspace_txt, fsep ="/")
workspace_PW1 <- file.path(system.file(package = "SticsRPacks"), parameters$workspace_PW1, fsep ="/")

# Generating html help files, one for each function
if(parameters$gen_help) {
  help_dir <- file.path(work_dir, "SticsRFiles_help")
  if (!dir.exists(help_dir)) dir.create(help_dir)
  SticsRFiles:::static_help(pkg = "SticsRFiles", 
                            overwrite = FALSE, 
                            out_dir = help_dir)
}
```

<!-- <div class="alert alert-danger"> -->
<!-- Test danger 2 -->
<!-- </div> -->

<!-- <div class="alert alert-warning"> -->
<!-- Test warning -->
<!-- </div> -->

<!-- <div class="alert alert-info"> -->
<!-- Test info -->
<!-- </div> -->

## Introduction

### The SticsRpacks packages

SticsRPacks is a set of packages for managing the STICS soil-crop model from R. 

It includes 4 packages:

* SticsRFiles: to manipulate STICS input and output files,
* SticsOnR: to run STICS simulations,
* CroPlotR: to plot models results / observations and compute stats,
* CroptimizR: to estimate model parameters.

SticsRFiles and SticsOnR are dedicated to the STICS model, while CroPlotR and CroptimizR are generic for crop models.

The websites of the different packages can be found at:

* [https://SticsRPacks.github.io/SticsRFiles/]
* [https://SticsRPacks.github.io/SticsOnR/]
* [https://SticsRPacks.github.io/CroPlotR/]
* [https://SticsRPacks.github.io/CroptimizR/]

### Finding documentation about the packages and their functions

There are different sources of documentation regarding the packages and their functions:

* the home pages of the packages websites (which links are given here-before), that introduce the packages main features,
* the vignettes (`Articles` tab at the top of the packages websites home pages), that describe in detail the main features of the packages and the use of the associated functions,
* the `Reference` tab at the top of the packages websites home pages, that lists and quickly describes all the exported functions of the packages, and gives links to their detailed documentation,
* the command `? functionName` in the R console,  which displays the detailed documentation of a given function.

Note also that completion can be used to list the different arguments of a function: if you type the name of a function in the R console followed by a bracket, e.g. `read.csv(` and then click on the `Tab` button of your keyboard, the list of arguments of the function will be displayed.

### The SticsRpacks tutorial

This tutorial aims at introducing the use of these different packages with the STICS model. It was designed to be of increasing complexity, it is thus advised to follow it in order. The different sections are however independent and you can thus start it from any part using the menu on the left side (this may however take a little while since results from previous exercises must be automatically generated in this case).

The names and documentation of the functions to be used are given in the first exercises before letting you find them on your own as you go through the exercises.

Most of the exercises in the tutorial requires writing and running a few lines of R code through R console panels like this one: 
```{r test, exercise=TRUE}
# Insert your R code here!
```

```{r test-hint-1}
# This is the first advise! 
```

```{r test-solution}
# Here's the SOLUTION:
get_var_info(keyword = "roots")
```

You just have to type the R code in the black part and click on the `Run Code` green button on the right side to run it. The results will be printed below the panel.

The `Start over` button re-initialize the panel.

If you don't find the solution, click on the button `Hints`, it will first give you some advises and finally the expected solution of the exercise. To copy the solution in the panel, click on the `Copy to Clipboard` blue button on the right and then right-click in the black part of the panel and select "paste".

## A foretaste of SticsRpacks 
<!-- Note : indications might be added about some technical tips: for example some parts may take some time
if they are not followed along the right order, needs for example to run simulations before exploiting outputs ... in part **Exploring and Evaluating the Stics results** -->

Let see first the possibilities offered by the SticsRPacks packages through two simple illustrative examples. At this stage it is not necessary to understand the code, the aim in this section is just to show you what we can do with a few lines of R codes, you will learn how to use all the functions used here in the next sections :-). If you feel lost in this section or are hurry to start learning how to use the packages you can skip it and go to the next one!

### STICS training Practical session PW1

The practical sessions of the STICS training are traditionally performed using the JavaStics GUI and Excel.

Let's see how the first sessions would look like in R using SticsRPacks.


The game is to run a single USM by activating and deactivating water and nitrogen stress in turns and to analyze the impact by looking at dynamic variables and stress indicators.

Let's first initialize variables and define the setup:

```{r, echo=TRUE, eval=TRUE, message=FALSE}

# Let's define the USM and variables of interest to use in this example
usm_name <- "maize_ref_2013"
stress_ind_names <- c("turfac1moy", "turfac2moy", "swfac1moy", "swfac2moy", "inn1moy", "inn2moy")
dyn_var_names <- c("lai_n","zrac","resmes","azomes","QNplante","masec_n")
var_names <- c(stress_ind_names,dyn_var_names)

# Set-up the simulation environment:
wrapper_options = stics_wrapper_options(javastics_path = javastics, data_dir = workspace_PW1)

# Generate the files for the simulation:
gen_usms_xml2txt(javastics, workspace_PW1, usms_list = usm_name)

```


Then, let's run the simulations for the different configurations:

```{r, echo=TRUE, eval=TRUE, message=FALSE}

# Simulate a reference situation with water and nitrogen stress
sim_ws_ns = stics_wrapper(model_options = wrapper_options, 
                          param_values = c(codeinnact=1, codeh2oact=1), 
                          var_names = var_names)$sim_list

# Simulate with water stress only
sim_ws = stics_wrapper(model_options = wrapper_options, 
                       param_values = c(codeinnact=2), 
                       var_names = var_names)$sim_list

# Simulate with N stress only
sim_ns = stics_wrapper(model_options = wrapper_options, 
                       param_values = c(codeh2oact=2), 
                       var_names = var_names)$sim_list

# Simulate with water stress only
sim_without_stress = stics_wrapper(model_options = wrapper_options, 
                                   param_values = c(codeinnact=2, codeh2oact=2), 
                                   var_names = var_names)$sim_list

```

Now we can use the simulated results to plot the dynamic variables of interest for the different configurations: 

```{r, echo=TRUE, eval=TRUE, message=FALSE}
plot(sim_ws_ns=sim_ws_ns, sim_ws=sim_ws, sim_ns=sim_ns, sim_without_stress=sim_without_stress, var = dyn_var_names )
```

Finally, we can plot the stress indicators averaged over vegetative and reproductive phases:

```{r, echo=TRUE, eval=TRUE, message=FALSE}

# Get the final values
df <- bind_rows(
  sim_ws_ns[[usm_name]] %>% summarise(across(.cols = stress_ind_names, last)) %>% 
  bind_cols(Case="sim_ws_ns"),
  sim_ws[[usm_name]] %>% summarise(across(.cols = stress_ind_names, last)) %>% 
  bind_cols(Case="sim_ws"),
  sim_ns[[usm_name]] %>% summarise(across(.cols = stress_ind_names, last)) %>% 
  bind_cols(Case="sim_ns"),
  sim_without_stress[[usm_name]] %>% summarise(across(.cols = stress_ind_names, last)) %>% 
  bind_cols(Case="sim_without_stress"))

# Plot bar graph with ggplot ... sorry, not yet available using CroPlotR ...
df_long <- tidyr::pivot_longer(df, stress_ind_names, names_to = "variables")
ggplot(df_long, aes(fill=Case, y=value, x=variables)) + geom_bar(position="dodge", stat="identity")

```

... and let the users interpret these results!

The last part may not be straightforward for R newcomers ... however a function to filter values of simulated variables at given dates and/or stages will come soon :-).


### Parameter optimization: A simple example

Here is an example use-case of an optimization of the `stamflax` parameter for a wheat crop using observations of Leaf Area Index for one situation (*i.e.* one USM):

```{r paged.print=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/SticsRPacks/SticsRPacks/master/inst/tutorials/SticsRpacks/optim_stamflax_wheat.png")
```

The code to get this is the following:

```{r simple-example-param-estim, echo=TRUE, eval=FALSE}
usm = "wheat"

# First, import the observations and filter them:
obs = get_obs(workspace = workspace_xml, usm_name = usm)
obs_filt = filter_obs(obs, "lai_n", include = TRUE)

# Set-up the simulation environment:
wrapper_options = stics_wrapper_options(javastics_path = javastics, data_dir = workspace_xml, parallel = TRUE)
optim_options = list(nb_rep = 3, path_results = workspace_xml)

# Define the parameter to optimize and the boundary values:
param_info = list(stamflax = list(lb = 200, ub = 400))

# Generate the files for the simulation:
gen_usms_xml2txt(javastics, workspace_xml, usms_list = usm)

# Make the optimization:
optim_res = estim_param(obs_list = obs_filt,
                        model_function = stics_wrapper,
                        model_options = wrapper_options,
                        optim_options = optim_options,
                        param_info = param_info)

# Import the results before/after the simulation and plot them:
sim_after_optim = stics_wrapper(param_values = optim_res$final_values, model_options = wrapper_options)$sim_list
sim_before_optim = stics_wrapper(model_options = wrapper_options)$sim_list

plot(after = sim_after_optim, before = sim_before_optim, obs = obs_filt, var = "lai_n")
```

A lot is happening here! 

But don't worry if you don't understand anything, you'll learn everything you need to know in this tutorial. We just want you to see that you can make a parameter optimization with less than 30 lines of code, including the plots of the improvement of the resulting simulated variable of interest against observation. And the good news is when you understand these lines of code, you'll be able to do almost anything with the packages, because it doesn't get any longer or more complex than this.  

OK now that we saw what we can do, let's find out how step by step.

## Finding names of STICS variables

Names of STICS variables can be retrieved from partial name or keywords using the `get_var_info` function of the [SticsRFiles package](https://SticsRPacks.github.io/SticsRFiles/index.html).

Here's its description as given in the R help panel (`? get_var_info`) and the [SticsRFiles package website](https://SticsRPacks.github.io/SticsRFiles/reference/get_var_info.html):

<blockquote>

```{r, results="asis"}
lines <- SticsRFiles:::get_from_help(file.path(help_dir, "get_var_info.html"))
cat(paste(lines, collapse="\n"))
```

</blockquote>

* Find all STICS variables characterizing roots

```{r get_var_info1, exercise=TRUE}
# Insert your R code here!
```

```{r get_var_info1-hint-1}
# Use argument keyword="roots"! 
```

```{r get_var_info1-solution}
# SOLUTION:
get_var_info(keyword = "roots")
```

<div class="alert alert-info">
See also: `get_param_info`, a function for retrieving name and information on STICS parameters.
</div>


## Exploring the content of the JavaStics files 

We're going to see in this section how to retrieve information from JavaStics input files.

### Get usm names

The function `get_usms_list` from the [SticsRFiles package](https://SticsRPacks.github.io/SticsRFiles/index.html) returns the list of USMs included in a usms.xml file.

Here's its description as given in the R help panel (`? get_usms_list`) and on the [SticsRFiles package website](https://SticsRPacks.github.io/SticsRFiles/reference/get_usms_list.html):

<blockquote>

```{r, results="asis"}
lines <- SticsRFiles:::get_from_help(file.path(help_dir, "get_usms_list.html"))
cat(paste(lines, collapse="\n"))
```

</blockquote>

* Get the list of USMs included in the `example` workspace of the JavaStics distribution, which path is stored in the R object `workspace_xml`.

```{r get_usms_list1, exercise=TRUE}
# Insert your R code here!
```

```{r get_usms_list1-hint-1}
# Use the file.path function to build full path to a file from directory names and filenames: file.path(path,filename) 
```

```{r get_usms_list1-solution}
# SOLUTION:
get_usms_list(usm_path = file.path(workspace_xml, "usms.xml"))
```

<!-- ```{r get_usms_list1-check} -->
<!-- grade_result( -->
<!--   pass_if(~identical(.result, get_usms_list(usm_path = file.path(workspace_xml, "usms.xml")))) -->
<!-- ) -->
<!-- ``` -->

* Get the list of cover-crops USMs (their name starts with `"cc_"`).

```{r get_usms_list2, exercise=TRUE}
# Insert your R code here!
```

```{r get_usms_list2-hint-1}
# The argument "name" is particularly useful in this case ...
```

```{r get_usms_list2-solution}
#SOLUTION:
get_usms_list(usm_path = file.path(workspace_xml, "usms.xml"), name = "cc_")
```

### Get parameters values from JavaStics input files

Parameters values included in JavaStics input files can be retrieved using the function `get_param_xml` from the [SticsRFiles package](https://SticsRPacks.github.io/SticsRFiles/index.html):

<blockquote>

```{r, results="asis"}
lines <- SticsRFiles:::get_from_help(file.path(help_dir, "get_param_xml.html"))
cat(paste(lines, collapse="\n"))
```

</blockquote>

* Get the values of clay content after decarbonation (argi) for all soils defined in the `sols.xml` file of the `workspace_xml` workspace of the JavaStics distribution.

```{r get_param_xml1, exercise=TRUE}
# Insert your R code here!
```

```{r get_param_xml1-hint-1}
# The path of the "sols.xml" file of the JavaStics example folder can be defined using the function file.path(workspace_xml, "sols.xml")
```

```{r get_param_xml1-solution}
#SOLUTION:
get_param_xml(file.path(workspace_xml, "sols.xml"), c("argi"))
```

```{r get_param_xml2-setup}
result <- get_param_xml(file.path(workspace_xml, "sols.xml"), c("argi"))
```

* Knowing that the result of the previous exercise has been stored in an R object called `result`, plot an histogram of the values of argi.

```{r get_param_xml2, exercise=TRUE}
# Insert your R code here!
```

```{r get_param_xml2-hint-1}
# Use the hist function to plot an histogram
```

```{r get_param_xml2-hint-2}
# Be careful, result is a list: argi is stored in result$sols.xml$argi
```

```{r get_param_xml2-solution}
#SOLUTION:
hist(result$sols.xml$argi)
```

* Compute the Available Water Capacity of soil `"solmais"` in mm

```{r get_param_xml3, exercise=TRUE}
# Insert your R code here!
```

```{r get_param_xml3-hint-1}
# Equation of Available Water Capacity in mm from STICS inputs is: AWC=sum((HCCF-HMINF)*epc*DAF/10)
```

```{r get_param_xml3-hint-2}
# Use select and value arguments of get_param_xml to extract information for a given soil
```

```{r get_param_xml3-solution}
# SOLUTION:
result <- get_param_xml(file.path(workspace_xml, "sols.xml"), c("HCCF", "HMINF", "epc", "DAF"), select = "sol", value = "solmais")
sum((result$sols.xml$HCCF - result$sols.xml$HMINF) * result$sols.xml$epc * result$sols.xml$DAF / 10)
```

### Get weather variables

Weather variables defined in STICS input weather files can be retrieved using the function `get_climate_txt` from the [SticsRFiles package](https://SticsRPacks.github.io/SticsRFiles/index.html):

<blockquote>

```{r, results="asis"}
lines <- SticsRFiles:::get_from_help(file.path(help_dir,"get_climate_txt.html"))
cat(paste(lines, collapse="\n"))
```

</blockquote>

* Compute the total amount of precipitation that has fallen in Auzeville in 2013 from the file `"Auzeville.2013"` of the JavaStics Example workspace.

```{r get_climate_txt1, exercise=TRUE}
# Insert your R code here!
```

```{r get_climate_txt1-hint-1}
# Precipitation is stored in the column named ttrr 
```

```{r get_climate_txt1-solution}
#SOLUTION:
result <- get_climate_txt(dirpath = workspace_xml, filename = "Auzeville.2013")
sum(result$ttrr)
```

* Compute the amount of precipitation that has fallen between dates `"2013-03-21"` and `"2013-09-20"`.

```{r get_climate_txt2, exercise=TRUE}
# Insert your R code here!
```

```{r get_climate_txt2-hint-1}
# Use dplyr::filter(result,Date>"2013-03-21", Date<"2013-09-20") to filter the results wrt the Dates.
```

```{r get_climate_txt2-solution}
#SOLUTION:
result <- get_climate_txt(dirpath = workspace_xml, filename="Auzeville.2013")
filtered_result <- dplyr::filter(result, Date > "2013-03-21", Date < "2013-09-20")
sum(filtered_result$ttrr)
```


## Running simulations from R

Let see now how to run STICS simulations directly from R using the function `run_javastics` from the [SticsOnR package](https://SticsRPacks.github.io/SticsOnR/index.html).

From now on we will no longer display function help in the tutorial. Use `? function_name` or explore the packages websites (in particular the Reference tab) to display it.

* Run all the USMs defined in the Example workspace of the JavaStics distribution. The path to JavaStics is stored in the `javastics` R object.

```{r run_javaStics1, exercise=TRUE, exercise.timelimit=300}
# Insert your R code here!
```


```{r run_javaStics1-hint-1}
# No need to use the usms_list argument!
```

```{r run_javaStics1-solution}
# SOLUTION:
run_javastics(javastics_path = javastics,  workspace_path = workspace_xml)
```

* Run only the USMs banana and Turmeric.

```{r run_javaStics2, exercise=TRUE}
# Insert your R code here!
```


```{r run_javaStics2-hint-1}
# Use the usms_list argument!
```

```{r run_javaStics2-solution}
# SOLUTION:
run_javastics(javastics_path = javastics,  workspace_path = workspace_xml, usms_list = c("banana","Turmeric"))
```

You can check that the corresponding Stics output files have been created in the folder `r workspace_xml`.


<div class="alert alert-info">
See also: `gen_varmod` function to modify var.mod file in case STICS does not simulate the variables you are interested in.
</div>


## Exploring and Evaluating the Stics results

### Getting simulations results

The `get_sim()` function can be used get simulation results to R from a Stics workspace. Some options allows filtering data, e.g. for given usm names or output variables. Check the function help before trying to use it.


```{r prepare-get_sim, echo=FALSE, message=FALSE, results='hide'}
usms <- get_usms_list(usm_path = file.path(workspace_xml, "usms.xml"))
sim_done <- length(list.files(pattern = "^mod_s", workspace_xml)) >=
  length(usms)

if (!sim_done) {
  print("Running simulations, please wait")
  run_javastics(javastics_path = javastics,
                workspace_path = workspace_xml) 
}
```

* Get the values of all the outputs simulated during the previous exercise in the `example` workspace

```{r get_sim1, exercise=TRUE, exercise.setup = "prepare-get_sim"}
# Insert your R code here! 

```
```{r get_sim1-hint-1}
# The path of results is stored in the workspace_xml object
```

```{r get_sim1-solution}
get_sim(workspace = workspace_xml)
```

* Get the values of all the outputs simulated for USMs banana and Turmeric

```{r get_sim2, exercise=TRUE, exercise.setup = "prepare-get_sim"}
# Insert your R code here! 
```

```{r get_sim2-hint-1}
# The argument usm_name is particularly useful in this case ...
```

```{r get_sim2-solution}
# SOLUTION
get_sim(workspace = workspace_xml, usm_name = c("banana","Turmeric"))
```

<!-- The tutorial is already quite long, maybe this exercise is not so useful -->
<!-- * Get outputs for the USMs of your choice other than banana, Turmeric -->

<!-- ```{r get_sim3, exercise=TRUE, exercise.setup = "prepare-get_sim"} -->
<!-- # Insert your R code here! -->

<!-- ``` -->

<!-- ```{r get_sim3-hint-1} -->
<!-- # Get the usms names list before choosing ... -->
<!-- ``` -->

<!-- ```{r get_sim3-hint-2} -->
<!-- # The function get_usms_list will be usefull -->
<!-- ``` -->

<!-- ```{r get_sim3-solution} -->
<!-- # SOLUTION -->
<!-- get_sim(workspace = workspace_xml, usm_name = c("wheat", "maize")) -->
<!-- ``` -->

* Get the values of the variable `lai_n` simulated for USMs `wheat` and `maize`

```{r get_sim4, exercise=TRUE, exercise.setup = "prepare-get_sim"}
# Insert your R code here!
```

```{r get_sim4-hint-1}
# Use the argument var_list for specifying which variable(s) to select ...
```

```{r get_sim4-solution}
# SOLUTION
get_sim(workspace = workspace_xml, usm_name = c("wheat", "maize"),
                   var_list = "lai_n")
```


<!-- Voir ou le mettre, ou alors l'integrer dans les manips ? -->

<div class="alert alert-info">
**Further information about get_sim options:**

By default, each element (i.e. data.frame per USM) of the returned object by `get_sim()` contains a `Plant` column in which are stored either `"plant_1"` or `"plant_2"` indicating if the corresponding variable values concern the principal or associated crop in case of intercrop simulation.

If the `usms.xml` file path is given to the function, plant file names are set in the `Plant` column. If both the `usms.xml` file path and the JavaStics path are given to the function, plant names are set in the `Plant` column and an additional column indicates those which correspond to a `Principal` or an `Associated` crop. 
</div>


### Plotting simulations results

The [CroPlotR](https://sticsrpacks.github.io/CroPlotR/) package can be used to plot simulated results as given by the `get_sim` function.

* Get the values of the variables `lai_n` and `masec_n` simulated for USM `wheat` and plot their dynamics

```{r plot_sim1, exercise=TRUE, exercise.setup = "prepare-get_sim"}
# Insert your R code here!
```

```{r plot_sim1-hint-1}
# Use get_sim first, as in the previous exercise ...
```

```{r plot_sim1-hint-2}
# Then you can use the plot function as described in the CroPlotR documentation on the website <https://SticsRPacks.github.io/CroPlotR/reference/plot.cropr_simulation.html> or from R using ?plot.cropr_simulation
```

```{r plot_sim1-solution}
# SOLUTION
results <- get_sim(workspace = workspace_xml, usm_name = "wheat",
                   var_list = c("lai_n", "masec_n"))
plot(results)
```

<div class="alert alert-info">
Note that `?plot` does not refer to the `plot` function defined in CroPlotR. To get the documentation about this function, either refer to the CroPlotR website or type `?plot.cropr_simulation`
</div>


* Then, do the same but plotting both variables on the same graph

```{r plot_sim2, exercise=TRUE, exercise.setup = "prepare-get_sim"}
# Insert your R code here!
```

```{r plot_sim2-hint-1}
# Use the "overlap" argument ...
```

```{r plot_sim2-hint-2}
# try using : overlap = list(list("lai_n","masec_n"))
```

```{r plot_sim2-solution}
# SOLUTION
results <- get_sim(workspace = workspace_xml, usm_name = "wheat",
                   var_list = c("lai_n", "masec_n"))
plot(results, overlap = list(list("lai_n","masec_n")))
```

### Evaluating simulations results

Evaluation of simulation results is performed using observation data by plotting dynamic graphs, scatter plots and by calculating statistical criteria. Observed data can be loaded by using the SticsRFiles `get_obs()` function and provided to CroPlotR functions. 

#### Getting observation data

* Get all the observation data included in the `example` workspace

```{r get_obs1, exercise=TRUE, exercise.setup = "prepare-get_sim"}
# Insert your R code here! 

```
```{r get_obs1-hint-1}
# Path of the observation files is the same as this of simulations outputs
```

```{r get_obs1-solution}
# SOLUTION
get_obs(workspace = workspace_xml)
```

* Get observations of `lai_n` and `masec_n` variables for USMs `wheat` and `maize`


```{r get_obs2, exercise=TRUE, exercise.setup = "prepare-get_sim"}
# Insert your R code here! 

```
```{r get_obs2-hint-1}
# Use the same syntax as for the get_sim function
```

```{r get_obs2-solution}
# SOLUTION
get_obs(workspace = workspace_xml, usm_name = c("wheat", "maize"), var_list = c("lai_n","masec_n"))
```


<div class="alert alert-info">
**Further information about get_obs options:**
The get_obs function supports the same optional arguments: usms.xml file path, JavaStics file path
for getting information about plant file or plant name for usms.
Please refer to the `get_sim()` use section for details.
</div>

####	Dynamic plots using observation data

As for the first exercise in the "Plotting simulations results" section, get the values of the variables `lai_n` and `masec_n` simulated for USM `wheat` and plot their dynamics, but this time add the observation data to the plot. 

```{r plot_simobs1, exercise=TRUE, exercise.setup = "prepare-get_sim"}
# Insert your R code here!
```

```{r plot_simobs1-hint-1}
# See previous exercises for dynamics plotting
```

```{r plot_simobs1-hint-2}
# Use the "obs" argument of the CroPlotR plot function
```

```{r plot_simobs1-solution}
# SOLUTION
results <- get_sim(workspace = workspace_xml, usm_name = c("wheat", "maize"))
observations <- get_obs(workspace = workspace_xml, usm_name = c("wheat", "maize"))
plot(results, var = c("lai_n","masec_n"), obs = observations)
```

<div class="alert alert-info">
Note that to plot some given variables, you can either filter their values when reading the results or when plotting them.
</div>


####	Basic scatter plot

Scatter plots are used for displaying simulated values against observed values. They can be produced using the same `plot()` function as for dynamics plots, with only changing the argument `type` of the `plot()` function.


* Get the values of the variables `lai_n` and `masec_n` simulated and observed for USMs `wheat` and `maize` and plot the corresponding scatter plot 

```{r plot_simobs2, exercise=TRUE, exercise.setup = "prepare-get_sim"}
# Insert your R code here!
```

```{r plot_simobs2-hint-1}
# Try type = "scatter" ;-)
```

```{r plot_simobs2-solution}
# SOLUTION
results <- get_sim(workspace = workspace_xml, usm_name = c("wheat", "maize"))
observations <- get_obs(workspace = workspace_xml, usm_name = c("wheat", "maize"))
plot(results, var = c("lai_n","masec_n"), obs = observations, type = "scatter")

```

####	Customized scatter plots using symbols

The symbols used in the scatter plots can be adapted by the user using optional specific arguments, either to plot one symbol per USMs or per group of USMs. 

* Plot the same scatter plot as in the previous exercise, but with one symbol per USM

```{r plot_simobs3, exercise=TRUE, exercise.setup = "prepare-get_sim"}
# Insert your R code here!
```

```{r plot_simobs3-hint-1}
# Look at the shape_sit argument ...
```

```{r plot_simobs3-solution}
# SOLUTION
results <- get_sim(workspace = workspace_xml, usm_name = c("wheat", "maize"))
observations <- get_obs(workspace = workspace_xml, usm_name = c("wheat", "maize"))
plot(results, var = c("lai_n","masec_n"), obs = observations, type = "scatter", shape_sit = "symbol")

```

* Now, plot the scatter plot for the same variables `lai_n` and `masec_n` but for USMs "wheat","DurumWheat", "maize" and "sorghum", and with different symbols for the 2 groups c("wheat","DurumWheat") and c("maize","sorghum")

```{r plot_simobs4, exercise=TRUE, exercise.setup = "prepare-get_sim"}
# Insert your R code here!
```

```{r plot_simobs4-hint-1}
# Set shape_sit = "group" and use the situation_group argument
```

```{r plot_simobs4-solution}
# SOLUTION
usms <- c("wheat","DurumWheat", "maize", "sorghum")
groups <- list(list("wheat","DurumWheat"), list("maize", "sorghum"))
results <- get_sim(workspace = workspace_xml, usm_name = usms)
observations <- get_obs(workspace = workspace_xml, usm_name = usms)
plot(results, var = c("lai_n","masec_n"), obs = observations, type = "scatter", shape_sit = "group", situation_group = groups)

```

####	Statistics and associated graphs

The `summary()` function can be used for computing statistical criteria measuring the fit of simulations to observations. These criteria can also be plotted using the `plot()` function. As for the `plot()` function, to get the documentation about `summary()`, either refer to the CroPlotR website or type `?summary.cropr_simulation`.


##### Statistics criteria

* Get the values of the variables `lai_n` and `masec_n` simulated and observed for USMs  `wheat`,`DurumWheat`, `maize`, and `sorghum` and compute the statistical criteria using the `summary()` function


```{r stat_simobs1, exercise=TRUE, exercise.setup = "prepare-get_sim"}
# Insert your R code here!
```

```{r stat_simobs1-hint-1}
# same use as for the plot function ...
```    

```{r stat_simobs1-solution}
# SOLUTION
usms <- c("wheat","DurumWheat", "maize", "sorghum")
results <- get_sim(workspace = workspace_xml, usm_name = usms, var = c("lai_n","masec_n"))
observations <- get_obs(workspace = workspace_xml, usm_name = usms, var = c("lai_n","masec_n"))

summary(results, obs = observations)

```

* Now do the same but compute the statistical criteria per USM

```{r stat_simobs2, exercise=TRUE}
# Insert your R code here!
```

```{r stat_simobs2-hint-1}
# use the argument all_situations ...
```

```{r stat_simobs2-solution, exercise.setup = "prepare-get_sim"}
# SOLUTION
usms <- c("wheat","DurumWheat", "maize", "sorghum")
results <- get_sim(workspace = workspace_xml, usm_name = usms, var = c("lai_n","masec_n"))
observations <- get_obs(workspace = workspace_xml, usm_name = usms, var = c("lai_n","masec_n"))

summary(results, obs = observations, all_situations = FALSE)

```

<!-- note
la premiere colonne est perturbante Version 1
si 1 jeu de simulation: superflue !!
utile en cas de comparaison de 2 jeu de simulations

Si 2 jeux: plutôt que le nom de colonne == group, simu (pour les graphes scatter group == groupes d'usms !)
-->

<!-- !!!!! voir pour ajouter un cas ou on nomme le jeu de sim
pour retrouver le nom dans la colonne "group"
-->



##### Statistics graphs

Statistical criteria can be plotted by providing the results of the `summary()` function to the `plot()` function.

For this purpose, the *R2* and *nRMSE* criteria will be used.

* Plot the `R²` and `nRMSE` criteria computed on all the USMs in the previous exercise

```{r stat_simobs3, exercise=TRUE, exercise.setup = "prepare-get_sim"}
# Insert your R code here!
```

```{r stat_simobs3-hint-1}
# Just use the object returned by the summary function in the plot function ...
```

```{r stat_simobs3-solution}
# SOLUTION
usms <- c("wheat","DurumWheat", "maize", "sorghum")
results <- get_sim(workspace = workspace_xml, usm_name = usms, var = c("lai_n","masec_n"))
observations <- get_obs(workspace = workspace_xml, usm_name = usms, var = c("lai_n","masec_n"))

summ <- summary(results, obs = observations, stat = c("R2","nRMSE"))

plot(summ, title = "for all USMs")

```

* Now do the same but per USM

```{r stat_simobs4, exercise=TRUE, exercise.setup = "prepare-get_sim"}
# Insert your R code here!
```

```{r stat_simobs4-hint-1}
# use the argument all_situations in summary ...
```

```{r stat_simobs4-solution}
# SOLUTION
usms <- c("wheat","DurumWheat", "maize", "sorghum")
results <- get_sim(workspace = workspace_xml, usm_name = usms, var = c("lai_n","masec_n"))
observations <- get_obs(workspace = workspace_xml, usm_name = usms, var = c("lai_n","masec_n"))

summ <- summary(results, obs = observations, all_situations = FALSE, stat = c("R2","nRMSE"))

plot(summ, title = "for each USM")

```

By default the results per USMs are plotted in bars having different columns 

* Now do the same but with USMs named in x axis

```{r stat_simobs5, exercise=TRUE, exercise.setup = "prepare-get_sim"}
# Insert your R code here!
```

```{r stat_simobs5-hint-1}
# Use the xvar argument of plot ...
```

```{r stat_simobs5-solution}
# SOLUTION
usms <- c("wheat","DurumWheat", "maize", "sorghum")
results <- get_sim(workspace = workspace_xml, usm_name = usms, var = c("lai_n","masec_n"))
observations <- get_obs(workspace = workspace_xml, usm_name = usms, var = c("lai_n","masec_n"))

summ <- summary(results, obs = observations, all_situations = FALSE, stat = c("R2","nRMSE"))

plot(summ, xvar = "situation", title = "USM names as X")

```


<div class="alert alert-info">
* `summary()` and `plot()` functions can also be used to compare the results of different versions of simulated results (e.g. same USMs simulated with different versions of the model or different input parameters). See online documentation on [CroPlotR site](https://SticsRPacks.github.io/CroPlotR/#223-statistics-plot) for more details. 
* When plotting the statistical criteria, it is important to select a (short) list of criteria to be plotted (and possibly of output variables) in order to ensure the readability of the graphs.
</div>


## Advanced use {#advanced-use}

You have learned so far how to use very useful but quite basic features of SticsRPacks packages.

Let's go now deeper into the packages functionalities.

## Generating JavaStics input Files

The different types of STICS input files can be generated using the [SticsRFiles package](https://SticsRPacks.github.io/SticsRFiles/index.html). 


### Generating JavaStics input files

The JavaStics Input files (XML format) can be generated from R using functions of the [SticsRFiles package](https://SticsRPacks.github.io/SticsRFiles/index.html). 

```{r gen_xml-1, echo=FALSE}
question("What is the name of the SticsRFiles function for generating a usms.xml file?",
         answer("gen_usms_xml2txt"),
         answer("get_usms_files"),
         answer("gen_usms_xml", correct = TRUE),
         answer("gen_usms"),
         incorrect = "Look at the Reference tab of the SticsRFiles website...",
         random_answer_order = TRUE,
         allow_retry = TRUE)
```


```{r gen_xml-2, echo=FALSE}
question("From which type of file the usms.xml file can be generated using this function?",
         answer("csv", correct = TRUE),
         answer("word"),
         answer("excel", correct = TRUE),
         answer("XML"),
         correct = "Great!",
         incorrect = "Look at the vignette \"Generating Stics XML files from tabulated data\" of the SticsRFiles website (Article tab)...",
         random_answer_order = TRUE,
         allow_retry = TRUE)
```


```{r gen_xml-3, echo=FALSE}
question("Which type of JavaStics files can not yet be generated using the gen_*_xml functions?",
         answer("Soil files"),
         answer("Weather data files", correct = TRUE),
         answer("General parameter files", correct = TRUE),
         answer("Technical files"),
         answer("Weather station files"),
         correct = "Incredible!",
         incorrect = "Look at the vignette \"Generating Stics XML files from tabulated data\" of the SticsRFiles website (Article tab)...",
         random_answer_order = TRUE,
         allow_retry = TRUE)
```

<div class="alert alert-info">
See also:

* Look at the vignette [Generating Stics XML files from tabulated data](https://SticsRPacks.github.io/SticsRFiles/articles/Generating_Stics_XML_files.html) for more details on how to use these functions!
* STICS input files (txt format) can be generated from a SticsRFiles R function: see section  below "Creating the text files".
</div>


### Generating observation files 

Observation files can be generated from a data.frame using the function `gen_obs` of the [SticsRFiles package](https://SticsRPacks.github.io/SticsRFiles/index.html).

They are not used by the STICS model but can be used to plot comparison between observed and simulated variables and to optimize STICS parameters both in JavaStics and in [CroPlotR](https://SticsRPacks.github.io/CroPlotR/index.html) and [CroptimizR](https://SticsRPacks.github.io/CroptimizR/index.html) packages as we have seen before.

* Generate observation files from the data stored in the `df` data.frame using the `gen_obs` function, check the files are created on your computer and check their content using the `get_obs` function.

```{r gen_obs, exercise=TRUE}
df <- data.frame(usm_name = c("usm1","usm1","usm2"), ian = c(2020,2021,2021), mo = c(12,7,7), jo = c(25,27,20),jul = c(359,573,566),`lai_n` = c(0.5,4.5,4.2), mafruit = c(NA,6.5,6.1))

# Insert your R code here!
```

```{r gen_obs-hint-1}
# Use the out_path argument of get_obs if you want to specify the path of the folder where the obs files will be created.
# By default they are created in the current working directory of the R process (given by getwd()).
```

```{r gen_obs-hint-2}
# Use the workspace argument of get_obs to specify the path to the folder containing the observation files.
# if you did not use the out_path argument in gen_obs, then use workspace = getwd() in get_obs.
```

```{r gen_obs-solution}
#SOLUTION:
gen_obs(obs_table = df)
get_obs(workspace = getwd())
```

<div class="alert alert-info">
Note that a subset of the observation files defined in the observation data.frame can be generated using the usms_list argument of gen_obs.
</div>

## Modifying JavaStics input files

[SticsRFiles](https://SticsRPacks.github.io/SticsRFiles/index.html) package also provides facilities for modifying JavaStics input files from R.

```{r set_param_xml-1, echo=FALSE}
question("What is the name of the SticsRFiles function for modifying JavaStics Input files (XML format)?",
         answer("set_param_xml", correct = TRUE), 
         answer("set_param_txt"),
         answer("gen_usms_xml"),
         answer("gen_usms"),
         incorrect = "Look at the Reference tab of the SticsRFiles website...",
         random_answer_order = TRUE,
         allow_retry = TRUE)
```

* Check the values of the nitrification code (`codenitrif`) for the soils defined in the `sols.xml` file of the JavaStics distribution example workspace (path to the JavaStics distribution example workspace is stored in the R object `workspace_xml`)

```{r set_param_xml-2, exercise=TRUE}
# Insert your R code here!
```

```{r set_param_xml-2-hint-1}
# Use function get_param_xml
```

```{r set_param_xml-2-solution}
# SOLUTION:
get_param_xml(xml_file = file.path(workspace_xml,"sols.xml"),  
              param_name = "codenitrif")
```

* Then, generate in the JavaStics distribution example workspace a new soil file called `sols_new.xml` for which all nitrification codes are set to 1 and check their values using the `get_param_xml` function.

```{r set_param_xml-3, exercise=TRUE}
# Insert your R code here!
```

```{r set_param_xml-3-hint-1}
# Use function set_param_xml
```

```{r set_param_xml-3-solution}
# SOLUTION:
set_param_xml(xml_file = file.path(workspace_xml,"sols.xml"),  
              param_name = "codenitrif", param_value = 1, out_path = file.path(workspace_xml,"sols_new.xml"))
get_param_xml(xml_file = file.path(workspace_xml,"sols_new.xml"),  
              param_name = "codenitrif")
```

<div class="alert alert-info">
Note that STICS input files (txt format) can also be modified from R using the `set_param_txt()` function.
</div>

## Running simulations from R using stics_wrapper

### The need of a wrapper

We saw earlier how to run a simulation using `run_javastics()`. This function simply calls javastics from the command line to run simulations. This does the same as running an USM by opening the javastics user interface, but from R. 

You are probably familiar with the xml files used as inputs for javastics (*e.g.* `sols.xml` or `usms.xml`). These files list all the parameter values for one or several usms, with potentially several soils, management practices and climate. Then when we run a given usm, javastics reads the parameters values from the xml files, and writes new text files with only the values associated to this particular usm. Then it calls the stics model that reads those text files, runs the simulation, and writes the outputs. 

So when we run a usm from javastics we have four different steps:

1. javastics reads the parameter values for the usm from the xml files
1. javastics writes text files with the parameter values that only describe this usm
1. javastics calls the stics model (*i.e* the stics executable)
1. the stics model reads the parameter values from the text files, runs a simulation, and writes the output files (*i.e.* `mod_bXXX.sti` and `mod_sXXX.sti`)

This method is simpler for the user because it hides the technical details, but it has some downsides: it is slow because we have to create the text files each time we make a simulation, and we cannot parallelize the simulations because we share the same text files.

But no worries, SticsRPacks provides a solution to this!

Instead of creating the text files one usm at a time, we create them for all usms once into one folder for each, and then we directly call the Stics model (*i.e* without using javastics) on these files. Using this method we are now able to run the simulations way faster, and in parallel! 

So how do we do that? Well, we use three steps:

- create the text files (`gen_usms_xml2txt()`)
- set-up our modeling environment (`stics_wrapper_options()`)
- run the simulations and import the results (`stics_wrapper()`)

### Creating the text files

The first step is to create the text files for each usms in a separate directory. To do so, we use `gen_usms_xml2txt()`.

This tutorial stores a javastics installation in the `javastics` variable, and an example workspace in the `workspace_xml` variable.

Before generating the text files, we will first restrain the number of variables we want stics to output using `gen_varmod`.

* Use `gen_varmod` to tell stics we only want "lai_n", "masec_n" and "QNplante"

```{r gen_varmod, exercise=TRUE}
# Insert your R code here!
```

```{r gen_varmod-hint-1}
# Use `javastics_path = javastics` and `workspace_path = workspace_xml`
```

```{r gen_varmod-solution}
#SOLUTION:
gen_varmod(workspace_xml, var_names = c("lai_n", "masec_n", "QNplante"))
```

It is generally useful (although not mandatory) to pre-filter the variables to avoid filtering the variables for the wrapper, the plots and the statistics.  

Now we can generate our text files. 

* Use the function `gen_usms_xml2txt()` to generate the text files for the usm "wheat", "banana" and "soybean":

```{r gen_usms_xml2txt, exercise=TRUE}
# Insert your R code here!
```

```{r gen_usms_xml2txt-hint-1}
# Use `javastics_path = javastics` and `workspace_path = workspace_xml`
```

```{r gen_usms_xml2txt-solution}
#SOLUTION:
gen_usms_xml2txt(javastics, workspace_xml, usms_list = c("wheat","banana","soybean"))
```

### Setting-up the modeling environment

Before running the simulations using Stics, we have to define some information about our modeling environment. This is done using `stics_wrapper_options()`. This function, defined in SticsOnR, helps us define where is our installation of javastics, which Stics executable to use (*e.g.* if you are using an executable from a research branch), which workspace to use, etc...

* Use `stics_wrapper_options()` to set-up our modeling environment using a parallel computation over the usms:

```{r stics_wrapper_options1, exercise=TRUE}
# Insert your R code here!
```

```{r stics_wrapper_options1-hint-1}
# Use `javastics_path = javastics` and `data_dir = workspace_xml`
```

```{r stics_wrapper_options1-solution}
#SOLUTION:
stics_wrapper_options(javastics_path = javastics, data_dir = workspace_xml, parallel = TRUE)
```

### Running the simulations

Now everything is set-up to make our simulations! The model options we will use here are stored in the `wrapper_options` object with the options we just set up in the previous section. 

```{r prepare-wrapper, echo=FALSE}
wrapper_options = stics_wrapper_options(javastics_path = javastics, data_dir = workspace_xml, parallel = TRUE)
```

<!-- Here is its output: -->
<!-- ```{r wrapper_options_print, exercise.setup = "prepare-wrapper"} -->
<!-- wrapper_options -->
<!-- ``` -->

* Now use `stics_wrapper()` to simulate the usm "wheat" only (not "banana" and "soybean") using the model options stored in `wrapper_options`, and return the leaf area index and the above-ground biomass:

```{r stics_wrapper1, exercise=TRUE, exercise.setup = "prepare-wrapper"}
# Insert your R code here!
```

```{r stics_wrapper1-hint-1}
# The sit_names argument is used to choose the usms to simulate.
```

```{r stics_wrapper1-hint-2}
# The var_names argument is used to choose the variables to return.
```

```{r stics_wrapper1-hint-3}
# Use get_var_info() to search for a variable name.
```

```{r stics_wrapper1-solution, exercise.setup = "prepare-wrapper"}
#SOLUTION:
stics_wrapper(model_options = wrapper_options, sit_names = "wheat", var_names = c("lai_n", "masec_n"))
```

<div class="alert alert-info">
* By default, if the `sit_names` argument is not given to `stics_wrapper()`, `stics_wrapper()` will run all the USMs defined in the sub-folders of the `data_dir` folder (`data_dir` is defined in `stics_wrapper_options()`).
* By default, if the `var_names` argument is not given to `stics_wrapper()`, `stics_wrapper()` will return results for all the variables defined in the var.mod files included in the sub-folders of the `data_dir` folder.
</div>


### Parameter forcing

Sometimes it is useful to compare the outputs of the model with a different value for one or several parameters to better understand its impact or check if it is used. 

`stics_wrapper()` provides an easy way to do so with the `param_values` argument. This argument is given as a named vector.

* Make a simulation on the "wheat" usm and output just the lai, but this time with `dlaimax = 0.005` and `durvieF = 80`:

```{r stics_wrapper2, exercise=TRUE, exercise.setup = "prepare-wrapper"}
# Insert your R code here!
```

```{r stics_wrapper2-hint-1}
# `param_values` is given as a named vector, e.g. c("bdens" = 5, "hautmax" = 1.1)
```

```{r stics_wrapper2-solution, exercise.setup = "prepare-wrapper"}
#SOLUTION:
stics_wrapper(model_options = wrapper_options, sit_names = "wheat", var_names = "lai_n", param_values = c("dlaimax" = 0.005, "durvieF" = 80))
```

### Plot the comparison

Now we can plot the outputs of the two simulations using the CroPlotR `plot()` function by giving the simulation objects as arguments (optionally named). The results of both simulations are accessible in the `res1` and `res2` objects. The results of the simulations are stored in the `sim_list` field of each object. For example to get the results of the simulation for `res1`, we would do: `res1$sim_list`. 

```{r prepare-wrapper-plot, echo=FALSE}
wrapper_options = stics_wrapper_options(javastics_path = javastics, data_dir = workspace_xml, parallel = TRUE)

res1 = stics_wrapper(model_options = wrapper_options, sit_names = "wheat", var_names = c("lai_n", "masec_n"))
res2 = stics_wrapper(model_options = wrapper_options, sit_names = "wheat", var_names = "lai_n", param_values = c("dlaimax" = 0.005, "durvieF" = 80))
```

Then, to plot a simulation result, we would do:

```{r stics_wrapperplot, exercise=TRUE, exercise.setup = "prepare-wrapper-plot"}
# Execute the code below to create a plot of the results:
plot(res1$sim_list)
```

It is also possible to compare the results of several simulations by giving them as arguments to the function one after the other.


* Plot the outputs of both simulations:

```{r stics_wrapper3, exercise=TRUE, exercise.setup = "prepare-wrapper-plot"}
# Insert your R code here!
```

```{r stics_wrapper3-hint-1}
# The simulation results can be listed one after the other in `plot()` for comparison
```

```{r stics_wrapper3-solution, exercise.setup = "prepare-wrapper-plot"}
#SOLUTION:
plot(res1$sim_list,res2$sim_list)
```

<div class="alert alert-info">
Only the `lai` variable was requested on the second simulation, that's why there is only the first simulation for masec.
</div>

We can also name the simulations in our plot by naming them when passed as arguments to `plot()`.

* Plot the outputs of both simulations, and name the first simulation "original" and the second simulation "dlaimax=0.005, durvieF=80":

```{r stics_wrapper4, exercise=TRUE, exercise.setup = "prepare-wrapper-plot"}
# Insert your R code here!
```

```{r stics_wrapper4-hint-1}
# Name the arguments of the plot function, e.g. plot("sim1" = res1) would name the simulation "sim1" (but would not output it on the plot because there is only one)
```

```{r stics_wrapper4-solution, exercise.setup = "prepare-wrapper-plot"}
#SOLUTION:
plot("original" = res1$sim_list,"dlaimax=0.005, durvieF=80" = res2$sim_list)
```

## Estimating parameters

### Workflow

Model calibration is an important part of most modeling work, but it can be complex and cumbersome. SticsRPacks provides a nice, standardized and easy way to estimate the values of parameters using observations through the CroptimizR `estim_param()` function.

The workflow for parameter estimation is made using several steps:

- Modeling environment set-up (`stics_wrapper_options()`). `estim_param()` uses `stics_wrapper()` under the hood to run each simulation, so we must set-up our modeling environment first as we saw before. 
- Import the observations for each usm (`get_obs()` + `filter_obs()`).
- Choose the parameter(s) to optimize and their boundary values.
- Set-up options for the optimization method,
- run the parameter optimization (`estim_param`).

```{r prepare-param-estim}
wrapper_options = stics_wrapper_options(javastics_path = javastics, data_dir = workspace_xml, parallel = TRUE)

obs = get_obs(workspace = workspace_xml, usm_name = "wheat")
obs_filt = filter_obs(obs, "lai_n", include = TRUE)

param_info = list(stamflax = list(lb = 200, ub = 400))

optim_options = list(nb_rep = 3, maxeval = 10, xtol_rel = 1e-03, path_results = workspace_xml, ranseed = 1234)
```

### Modelling environment

We will simply re-use the modeling environment from the previous exercise: `wrapper_options`. This is how we did it:

```r
wrapper_options = stics_wrapper_options(javastics_path = javastics, data_dir = workspace_xml, parallel = TRUE)
```

### Observations

* Import the observations for the "wheat" usm, and put it in an object called `obs`:

```{r estim_param_obs1, exercise=TRUE, exercise.setup = "prepare-param-estim"}
# Insert your R code here!
```

```{r estim_param_obs1-hint-1}
# Use `get_obs()`, workspace_xml is the workspace.
```

```{r estim_param_obs1-solution}
#SOLUTION:
obs = get_obs(workspace = workspace_xml, usm_name = "wheat")
```

* Filter the observations to get only the lai using `filter_obs()`, and put it in an object called `obs_filt`:

```{r estim_param_obs2, exercise=TRUE, exercise.setup = "prepare-param-estim"}
# Insert your R code here!
```

```{r estim_param_obs2-hint-1}
# Use the argument var_names in filter_obs ...
```

```{r estim_param_obs2-solution}
#SOLUTION:
obs_filt = filter_obs(obs, "lai_n", include = TRUE)
```

### Parameters of the optimization method  

The optimization methods available in CroptimizR have some parameters too. For example the simplex method has the following:

- `nb_rep`: Number of times the minimization process is done, each time starting with a different set of initial
parameters values. This one is used to control whether our initial values impact our resulting optimized value or not. The more is better, but the whole optimization process is repeated `nb_rep` so it takes more and more time.
- `maxeval`: Maximum number of evaluations of the minimized criteria. That is to say the algorithm is stopped if it did not converge to a value after `maxeval` runs.
- `xtol_rel`: Tolerance criterion between two iterations, *i.e.* stop the algorithm when an optimization step (or an estimate of the optimum) changes every parameter by less than xtol_rel multiplied by the absolute value of the parameter.
- `path_results`: path to the directory on which the results will be written (graph and .Rdata)
- `ranseed`: set the random seed so that each execution give the same results. If you want full randomization, don't set it.

Only `path_results` is mandatory, all the others have default values.

<div class="alert alert-note">
More information can be found on the CroptimizR vignettes, e.g. [here](https://SticsRPacks.github.io/CroptimizR/articles/Parameter_estimation_simple_case.html).
</div>

These parameters are passed to `estim_param` as a named list.

* Make a named list to set values for these parameters and put the results in an object named `optim_options`. We require 3 repetitions and max_eval=10 (to make it quick ... in real life you should set max_eval to a large value to let the process converge). You can use any directory to store the results. If you don't particularly care where to put them, you can put them in `workspace_xml`.

```{r estim_param_options, exercise=TRUE}
# Insert your R code here!
```

```{r estim_param_options-hint-1}
# A name list is constructed like so: list(name1 = value1, name2 = value2)
```

```{r estim_param_options-solution}
#SOLUTION:
optim_options = list(nb_rep = 3, max_eval=10, path_results = workspace_xml)
```

### Choose parameter

We have to choose which parameter will be optimized, and what are their respective boundary values. To do so, we define a list of list for each parameter like so: 

```r
param_info = list()
param_info$dlaimax = list(lb = 0.0005, ub = 0.0025)
param_info$durvieF = list(lb = 100, ub = 450)
```

<div class="alert alert-note">
You can get more information about parameters using `get_param_info`.
</div>

Let's try to optimize the value of the `stamflax` parameter. 

* Create the parameter list for `stamflax` and name it `param_info`.

```{r estim_param_param, exercise=TRUE}
# Insert your R code here!
```

```{r estim_param_param-hint-1}
# You can use 200 and 400 for boundary values
```

```{r estim_param_param-solution}
#SOLUTION:
param_info = list(stamflax = list(lb = 200, ub = 400))
```

### Optimization

Now that we defined all information we needed, we can use `estim_param()` to make the optimization. 

As a reminder, here's the objects we previously defined:

- `obs_filt`: the observations to use in the optimization  
- `stics_wrapper`: this is the wrapper function for stics
- `wrapper_options`: the options passed to `stics_wrapper`
- `optim_options`: the parameters for the optimization method 
- `param_info`: the parameter(s) names and boundary values

* Now estimate the value of `stamflax` using `estim_param()` and the previous objects we defined, and put the results in an object called `optim_res`.

```{r estim_param2, exercise=TRUE, exercise.setup = "prepare-param-estim", exercise.timelimit=300}
# Insert your R code here!
```

```{r estim_param2-hint-1}
# Read the documentation of estim_param() and associate the aforementioned objects to the corresponding arguments.
```

```{r estim_param2-solution}
#SOLUTION:
optim_res = estim_param(obs_list = obs_filt,
                        model_function = stics_wrapper,
                        model_options = wrapper_options,
                        optim_options = optim_options,
                        param_info = param_info)
```

<div class="alert alert-note">
The optimization process can take a while. Time to drink a ☕ maybe! 

If you don't want to wait for the optimization process, we got you covered. You 
can still continue to the next exercises because we cached the output for you (we stored the result of `estim_param()` in the object `optim_res`, but running it with the default value of `max_eval`).

If you didn't do the previous exercises about generating stics text files, you might 
want to execute `gen_usms_xml2txt` before `estim_param` like so:

```r
gen_usms_xml2txt(javastics, workspace_xml, usms_list = c("wheat","banana","soybean"))
```
</div>

<div class="alert alert-info">
* The default parameter estimation method used in `estim_param()` is the minimization of a least square criterion using the Nelder-Mead simplex. However, different methods and criteria can be used. Look (here)[https://sticsrpacks.github.io/CroptimizR/articles/Available_parameter_estimation_algorithms.html] for more details about the available methods and criteria.
* The results provided by `estim_param()` depend on the method used. Graphs and .Rdata produced are stored in `optim_options$path_results`. `estim_param()` also displays some results on the standard output (see here-before) and returns a list including the main results (stored here in the `optim_res` object). In the case of the simplex method this list includes:

  * the values of the estimated parameters (`final_values`),
  * the initial values used for each repetition (`init_values`),
  * the optimized value of the criterion for each repetition (`crit_values`), 
  * ...

</div>


```{r prepare-param-estim-out}
load(file = system.file("extdata/optim_results.Rdata", package = "SticsRPacks"))
optim_res = res
rm(res)
wrapper_options = stics_wrapper_options(javastics_path = javastics, data_dir = workspace_xml, parallel = TRUE)
obs_filt = filter_obs(get_obs(workspace = workspace_xml, usm_name = "wheat"), "lai_n", include = TRUE)
sim_after_optim = stics_wrapper(param_values = optim_res$final_values, model_options = wrapper_options, sit_names = "wheat")$sim_list
gen_usms_xml2txt(javastics, workspace_xml, usms_list = c("wheat","banana","soybean"))
sim_before_optim = stics_wrapper(model_options = wrapper_options, sit_names = "wheat")$sim_list
```

### Plots

Now that our parameter value is optimized, we can re-run the model with this value to check the results.
To do so, we call again `stics_wrapper` with the optimized value passed as argument.

* Use `stics_wrapper` to make a new simulation of the `wheat` USM with our optimized value `optim_res$final_values`, and put only the results (not the errors) in an object called `sim_after_optim` (see documentation for the outputs of `stics_wrapper`.

```{r estim_param3, exercise=TRUE, exercise.setup = "prepare-param-estim-out"}
# Insert your R code here!
```

```{r estim_param3-hint-1}
# Read the documentation of stics_wrapper() and use the `param_values` argument along with the resulting optimized value stored in `optim_res$final_values`.
```

```{r estim_param3-hint-2}
# Use the sit_names argument of stics_wrapper() to select the USM to simulate.
```

```{r estim_param3-hint-3}
# stics_wrapper() returns a list of two:
# - sim_list for the results
# - error for indications on errors 
# We need only the results in our object `sim_after_optim`.
```

```{r estim_param3-solution}
#SOLUTION:
sim_after_optim = stics_wrapper(param_values = optim_res$final_values, model_options = wrapper_options, sit_names = "wheat")$sim_list
```

Now we can plot the output using `plot()`.

* Use `plot()` to make a dynamic plot of the simulations along with the observations (`obs_filt`) for the `lai_n` variable.

```{r estim_param4, exercise=TRUE, exercise.setup = "prepare-param-estim-out"}
# Insert your R code here!
```

```{r estim_param4-hint-1}
# Read the documentation of plot(). This one is tricky, you can either see it on the package website <https://SticsRPacks.github.io/CroPlotR/reference/plot.cropr_simulation.html> or from R using ?plot.cropr_simulation
```

```{r estim_param4-solution}
#SOLUTION:
plot(sim = sim_after_optim, obs = obs_filt, var = "lai_n")
```

We can also make a scatter plot for a different display of the fit between observations and simulations.

* Make the same plot but as a scatter plot instead of a dynamic plot

```{r estim_param5, exercise=TRUE, exercise.setup = "prepare-param-estim-out"}
# Insert your R code here!
```

```{r estim_param5-hint-1}
# Read the documentation of plot(). This one is tricky, you can either see it on the package website <https://SticsRPacks.github.io/CroPlotR/reference/plot.cropr_simulation.html> or from R using ?plot.cropr_simulation
```

```{r estim_param5-solution}
#SOLUTION:
plot(sim = sim_after_optim, obs = obs_filt, type = "scatter", var = "lai_n")
```

### Before/after comparison

It is often interesting to compare the simulations before and after the optimization to investigate if it worked properly. To do so, we just have to simulate both, and to plot the results using `plot()`.

* Make a simulation using `stics_wrapper` with the original values

```{r estim_param6, exercise=TRUE, exercise.setup = "prepare-param-estim-out"}
# Insert your R code here!
```

```{r estim_param6-hint-1}
# estim_param() does not modify the input files, so you can just re-simulate the usm "wheat" with stics_wrapper
```

```{r estim_param6-solution}
#SOLUTION:
sim_before_optim = stics_wrapper(model_options = wrapper_options, sit_names = "wheat")$sim_list
```

Now we can compare the simulations using `plot()` and `summary()`.

* Make a plot to compare both simulations for `lai_n`

```{r estim_param7, exercise=TRUE, exercise.setup = "prepare-param-estim-out"}
# Insert your R code here!
```

```{r estim_param7-hint-1}
# Read the documentation of plot(). This one is trick, you can either see it on the package website <https://SticsRPacks.github.io/CroPlotR/reference/plot.cropr_simulation.html> or from R using ?plot.cropr_simulation
```

```{r estim_param7-solution}
#SOLUTION:
plot(before_optim=sim_before_optim, after_optim=sim_after_optim, obs= obs_filt, var = "lai_n")
```

* Compute the nRMSE and Bias of both simulations for `lai_n` using `summary()` 

```{r estim_param8, exercise=TRUE, exercise.setup = "prepare-param-estim-out"}
# Insert your R code here!
```

```{r estim_param8-hint-1}
# Read the documentation of summary(). This one is trick, you can either see it on the package website <https://SticsRPacks.github.io/CroPlotR/reference/summary.cropr_simulation.html> or from R using ?summary.cropr_simulation
```

```{r estim_param8-hint-2}
# use the "stat" argument of summary to select the criteria to compute ...
```


```{r estim_param8-solution}
#SOLUTION:
summary(before_optim=sim_before_optim, after_optim=sim_after_optim, obs = obs_filt, stat=c("nRMSE", "Bias"))
```

## Managing successive crops 

Work In Progress ...

We will show here that we can use `stics_wrapper()` to run successive situations, `plot()` to plot variables continuously in dynamic crops and `estim_param()` to estimate parameters using successive simulations. 

If you are interested, you can check the documentation of `stics_wrapper_options()` (argument `successive_usms`), `plot()` (argument `successive`) and `estim_param` (use of `sit_list`in `param_info` argument).

## Managing Intercrops

We will see in this section how intercrops are handled in SticsRPacks.

* Run the "intercrop_pea_barley" USM of the JavaStics distribution example workspace from R, get the results of lai_n, masec_n and mafruit for both crops and store them in an R object called `sim` (path to JavaStics is stored in the `javastics` R object and path to the example workspace is stored in `workspace_xml`)

```{r intercrop-1, exercise=TRUE}
# Insert your R code here!
```

```{r intercrop-1-hint-1}
# Use the run_javastics function with the usms_list argument to run the intercrop_pea_barley USM ...
```

```{r intercrop-1-hint-2}
# Use the get_sim function with the usms_list and var_list arguments to get the required results.
```

```{r intercrop-1-solution}
# SOLUTION:
run_javastics(javastics_path=javastics,  workspace_path = workspace_xml, usms_list = c("intercrop_pea_barley"))
sim <- get_sim(workspace = workspace_xml, usm_name="intercrop_pea_barley",var_list=c("lai_n","masec_n","mafruit"))
```


* Examine the results and try to answer the quizz below


```{r prepare-intercrop-2, echo=FALSE}
run_javastics(javastics_path=javastics,  workspace_path = workspace_xml, usms_list = c("intercrop_pea_barley"))
sim <- get_sim(workspace = workspace_xml, usm_name="intercrop_pea_barley",var_list=c("lai_n","masec_n","mafruit"))
```

```{r intercrop-2, exercise=TRUE, exercise.setup = "prepare-intercrop-2"}
# Insert your R code here!
```

```{r intercrop-2-hint-1}
# You just have to print sim ...
```

```{r intercrop-2-solution}
print(sim)
```

```{r intercrop-3, echo=FALSE}
question("How are organized the results for the different intercrops",
         answer("In a single data.frame per USM, the results for the different crops being flagged by Plant and Dominance columns", correct = TRUE), 
         answer("In different data.frames, depending on the crop"),
         incorrect = "You're not lucky ... the correct proposition is the other one!",
         random_answer_order = TRUE,
         allow_retry = TRUE)
```

* Check now how results are changed when you use the `usms_filepath` argument of the `get_sim` function

```{r intercrop-4, exercise=TRUE, exercise.setup = "prepare-intercrop-2"}
# Insert your R code here!
```

```{r intercrop-4-solution}
# SOLUTION:
sim <- get_sim(workspace = workspace_xml, usm_name="intercrop_pea_barley",
               var_list=c("lai_n","masec_n","mafruit"),
               usms_filepath = "usms.xml")
print(sim)
# The names of the Plant files are now given in the Plant column instead of Plant_1 and Plant_2 ...
```


* And, finally, how results are changed when you use in addition the `javastics_path` argument of the `get_sim` function


```{r intercrop-5, exercise=TRUE, exercise.setup = "prepare-intercrop-2"}
# Insert your R code here!
```

```{r intercrop-5-solution}
# SOLUTION:
sim <- get_sim(workspace = workspace_xml, usm_name="intercrop_pea_barley",
               var_list=c("lai_n","masec_n","mafruit"),
               usms_filepath ="usms.xml", javastics_path=javastics)
print(sim)
# The names of the Plants are now given in the Plant column.
```

* Now, plot the simulation results using the standard plot function of CroPlotR

```{r prepare-intercrop-6, echo=FALSE}
sim <- get_sim(workspace = workspace_xml, usm_name="intercrop_pea_barley",
               var_list=c("lai_n","masec_n","mafruit"),
               usms_filepath = "usms.xml", javastics_path=javastics)
```

```{r intercrop-6, exercise=TRUE, exercise.setup = "prepare-intercrop-6"}
# Insert your R code here!
```

```{r intercrop-6-solution}
# SOLUTION:
plot(sim)
```



## Advanced parameter estimation 


Work In Progress ...

We will show here advanced features of the `estim_param()` function:

* use of inequality constraints between parameters (see argument `satisfy_par_const`),
* simultaneous estimation of different values of the same parameters depending on the USMs (use of `sit_list`in `param_info` argument, see (here)[https://sticsrpacks.github.io/CroptimizR/articles/Parameter_estimation_Specific_and_Varietal.html] for a detailed example),
* use of bayesian methods (see (here)[https://sticsrpacks.github.io/CroptimizR/articles/Parameter_estimation_DREAM.html] for a detailed example)

